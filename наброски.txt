
/*инициализзация периферий:
RCC - хватит ли системной частоты 8 МГц? 
GPIO PC5 переводит в power down -> при получении команды через UART 
АЦП(температурный датчик) - почитать 
SPI
UART
*/
flash-memory - почитать. Почитать как сохранять инфу (можно вспомнить MSP430) 
нужно сохранять значения из RAM? Или копировать во флеш данные из регистров
больше всего непоняток с флеш: 
когда записывать и когда считывать сохраненые данные. Записывать ли их сразу после передачи по юарт? 
какие прерывания использовать? скорее всего - UART, SPI(?)

/*
какие данные мы должны передать по SPI, which SPI-mode, frequency, frame, fullduplex or half-duplex - зависит от микрухи
/*SPI*/
MSB
polarity - ?
CHPA-?

передали три кадра данных, выставили LE в 1, тк LE защелкивает данные и передает из входного регистра в микруху
/*uart*/
скорость UART? 115200
сколько стоповых битов? 1
контроль четности none
сколько битов в кадре? 8

*/

/*нужно ли использовать подтяжку резисторами на выходе GPIO для LE, CE*/


почистить код от прототипов неиспользуемых функций
проверить че делают те или иные функции

что можно сделать? Проверить какие функции нужны, остальное - закомментить, либо вытащить в main.c, main.h.
0) обработчики ошибок
1) UART и все вопросы, связанные с этой переферией:
/*структура параметров конфигурации (а где она - хз)*/
typedef struct
{
USART_TypeDef  *Instance;        // базовый адрес регистров UART
UART_InitTypeDef  Init;             // структура основных параметров UART
uint8_t  *pTxBuffPtr;      // указатель на передающий буфер
uint16_t  TxXferSize;       // количество передаваемых данных
__IO uint16_t  TxXferCount;      // счетчик передаваемых данных
uint8_t  *pRxBuffPtr;      // указатель на приемный буфер
uint16_t  RxXferSize;       // количество принимаемых данных
__IO uint16_t  RxXferCount;      // счетчик полученных данных
DMA_HandleTypeDef  *hdmatx;      // структура параметров DMA для передачи
DMA_HandleTypeDef  *hdmarx;      // структура параметров DMA для приема
HAL_LockTypeDef  Lock;   // блокировка объекта
__IO HAL_UART_StateTypeDef    gState;         // состояние UART
__IO HAL_UART_StateTypeDef    RxState;         // состояние UART
__IO uint32_t                 ErrorCode;        // коды ошибок
}UART_HandleTypeDef;



необходимые функции: 
чтение, запись (нужно ли исполтзовать проверку флагов или функция делает это сама - полагаю, что сама), соотв. буферы
обработчик прерываний

   
   тогда UART находится в режиме чтения (соотв-но нужна функция ожидания команды или типа того и чтобы команда завершалась нажатием enter) 
   если поступает запрос на настройку частоты, UART пишет в терминал че-то типа "Enter frequecy in xxx format:"  и ожидает ввод с консоли значения частоты (ввод завершается нажатием enter)
   если поступает
   


